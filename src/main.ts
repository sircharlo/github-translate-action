import * as core from '@actions/core';
import * as github from '@actions/github';
import { createIssueComment, translate } from './utils';
import getModel from './modes';
import { translateText } from './utils/translate';

const TITLE_DIVIDER = ` || `;
const TRANSLATION_DIVIDER = `<!--This is a translation content dividing line, the content below is generated by machine, please do not modify the content below-->`;

const DEFAULT_BOT_MESSAGE = `The translation bot detected that the issue body is not in English and translated it automatically. Please note that this is a machine translation, and may not be accurate.`;

const BOT_TOKEN = process.env.GITHUB_TOKEN;

/**
 * Removes quoted Markdown lines ("> ...") to avoid re-translating old comments.
 */
function stripQuotedLines(content?: string): string | undefined {
  return content
    ?.split('\n')
    .filter((line) => !line.trimStart().startsWith('>'))
    .join('\n')
    .trim();
}

async function main(): Promise<void> {
  core.info(JSON.stringify(github.context));

  if (!BOT_TOKEN) {
    return core.setFailed(`GITHUB_TOKEN is required!`);
  }

  const modifyTitle = core.getInput('IS_MODIFY_TITLE') === 'true';
  const appendTranslation = core.getInput('APPEND_TRANSLATION') === 'true';
  const botNote =
    core.getInput('CUSTOM_BOT_NOTE')?.trim() || DEFAULT_BOT_MESSAGE;
  const skipActorsInput = core.getInput('SKIP_ACTORS')?.trim();

  const {
    payload: { issue, discussion, pull_request, comment },
  } = github.context;

  /**
   * Skip translation for selected users
   */
  if (skipActorsInput) {
    const skipList = skipActorsInput.split(',').map((a) => a.trim());
    const author =
      comment?.user?.login ??
      issue?.user?.login ??
      discussion?.user?.login ??
      pull_request?.user?.login;

    if (author && skipList.includes(author)) {
      return core.info(`Skipping translation for author: ${author}`);
    }
  }

  const model = getModel();
  if (!model || !model.match) return;

  const { title, body, update } = model;
  const octokit = github.getOctokit(BOT_TOKEN);

  const originalTitle = title?.split(TITLE_DIVIDER)?.[0];
  let originalBody = body?.split(TRANSLATION_DIVIDER)?.[0];

  // Remove quoted text
  originalBody = stripQuotedLines(originalBody);

  const textToTranslate = translateText.stringify(originalBody, originalTitle);
  if (!textToTranslate) return;

  core.info(`Translate origin body: ${textToTranslate}`);

  const translated = await translate(textToTranslate);
  if (!translated || translated === textToTranslate) {
    return core.warning('Translated text is null or identical. Ignoring.');
  }

  core.info(`Translated result: ${translated}`);

  let [translatedBody, translatedTitle] = translateText.parse(translated);

  /**
   * Mode 1 — Append translation to the original content
   */
  if (appendTranslation) {
    const finalTitle =
      translatedTitle &&
      translatedTitle !== originalTitle &&
      `${originalTitle}${TITLE_DIVIDER}${translatedTitle}`;

    const finalBody =
      translatedBody &&
      translatedBody !== originalBody &&
      `${originalBody}
${TRANSLATION_DIVIDER}
---
###### ${botNote}

${translatedBody}
`;

    await update(octokit, finalBody || undefined, finalTitle || undefined);
    return;
  }

  /**
   * Mode 2 — Post translation as a separate bot comment
   */
  const bodyChanged = translatedBody && translatedBody !== originalBody;

  const commentBody = `
> ${botNote}
----
${!modifyTitle && translatedTitle ? `**Title:** ${translatedTitle}\n` : ''}
${translatedBody ?? ''}
`.trim();

  // Update title if required
  if (modifyTitle && translatedTitle && translatedTitle !== originalTitle) {
    await update(octokit, undefined, translatedTitle);
  }

  // Post comment if content changed
  if (bodyChanged) {
    await createIssueComment({
      pull_number: pull_request?.number,
      discussion_number: discussion?.node_id,
      issue_number: issue?.number,
      body: commentBody,
      octokit,
    });
  }

  core.setOutput('complete time', new Date().toTimeString());
}

async function run() {
  try {
    await main();
  } catch (err: any) {
    core.setFailed(err.message);
  }
}

run();
