import * as core from '@actions/core';
import * as github from '@actions/github';
import { createIssueComment, translate } from './utils';
import getModel from './modes';
import { translateText } from './utils/translate';

const TRANSLATION_DIVIDER = `
<!--This is a translation content dividing line, the content below is generated by machine, please do not modify the content below-->`;

const DEFAULT_BOT_MESSAGE = `The translation bot detected that the issue body is not in English and translated it automatically.
Please note that this is a machine translation, and may not be accurate.`;

const BOT_TOKEN = process.env.GITHUB_TOKEN;

/**
 * Removes quoted Markdown lines ("> ...") to avoid re-translating old comments.
 */
function stripQuotedLines(content?: string): string | undefined {
  return content
    ?.split('\n')
    .filter((line) => !line.trimStart().startsWith('>'))
    .join('\n')
    .trim();
}

/**
 * Extracts tags from title (e.g., "[Bug]", "[Feature Request]") and returns
 * the tags and the title without tags.
 */
function extractTitleTags(title?: string): {
  tags: string;
  titleWithoutTags: string;
} {
  if (!title) return { tags: '', titleWithoutTags: '' };

  // Match all tags at the beginning like [Bug], [Feature], etc.
  const tagRegex = /^(\[.+?\](?:\s*\[.+?\])*)\s*:?\s*/;
  const match = title.match(tagRegex);

  if (match) {
    const tags = match[1];
    const titleWithoutTags = title.slice(match[0].length).trim();
    return { tags, titleWithoutTags };
  }

  return { tags: '', titleWithoutTags: title };
}

/**
 * Formats a translated title with preserved tags and original title reference.
 * Format: [TAG(S)] TRANSLATED (Original title: ORIGINAL_NO_TAGS)
 */
function formatTitleWithTags(
  originalTitle: string,
  translatedTitle: string,
): string {
  const { tags, titleWithoutTags: originalWithoutTags } =
    extractTitleTags(originalTitle);
  const { titleWithoutTags: translatedWithoutTags } =
    extractTitleTags(translatedTitle);

  // If there are tags, format with tags + translation + original reference
  if (tags) {
    return `${tags} ${translatedWithoutTags} (Original title: ${originalWithoutTags})`;
  }

  // No tags, just add original reference
  return `${translatedWithoutTags} (Original title: ${originalWithoutTags})`;
}

async function main(): Promise<void> {
  core.info(JSON.stringify(github.context));

  if (!BOT_TOKEN) {
    return core.setFailed(`GITHUB_TOKEN is required!`);
  }

  const modifyTitle = core.getInput('IS_MODIFY_TITLE') === 'true';
  const appendTranslation = core.getInput('APPEND_TRANSLATION') === 'true';
  const botNote =
    core.getInput('CUSTOM_BOT_NOTE')?.trim() || DEFAULT_BOT_MESSAGE;
  const skipActorsInput = core.getInput('SKIP_ACTORS')?.trim();

  const {
    payload: { issue, discussion, pull_request, comment },
  } = github.context;

  /**
   * Skip translation for selected users
   */
  if (skipActorsInput) {
    const skipList = skipActorsInput.split(',').map((a) => a.trim());
    const author =
      comment?.user?.login ??
      issue?.user?.login ??
      discussion?.user?.login ??
      pull_request?.user?.login;

    if (author && skipList.includes(author)) {
      return core.info(`Skipping translation for author: ${author}`);
    }
  }

  const model = getModel();
  if (!model || !model.match) return;

  const { title, body, update } = model;
  const octokit = github.getOctokit(BOT_TOKEN);

  const originalTitle = title;

  // Check if title has already been translated
  const titleAlreadyTranslated =
    originalTitle && originalTitle.includes('Original title:');
  if (titleAlreadyTranslated) {
    core.info(
      'Title already contains "Original title:" - will skip retranslating title but will still process body.',
    );
  }

  // Handle edited messages: if body contains botNote, strip translation to retranslate
  let originalBodyWithQuotes = body;
  if (body && body.includes(botNote)) {
    core.info(
      'Body contains botNote - this appears to be an edit. Stripping translation content to retranslate.',
    );
    originalBodyWithQuotes = body.split(TRANSLATION_DIVIDER)?.[0];
  } else {
    originalBodyWithQuotes = body?.split(TRANSLATION_DIVIDER)?.[0];
  }

  // Extract tags from title for separate handling
  const { titleWithoutTags: originalTitleWithoutTags } =
    extractTitleTags(originalTitle);

  // Remove quoted text for translation (to avoid re-translating old comments)
  const originalBodyForTranslation = stripQuotedLines(originalBodyWithQuotes);

  // Translate only the title without tags (unless already translated)
  const textToTranslate = translateText.stringify(
    originalBodyForTranslation,
    titleAlreadyTranslated ? undefined : originalTitleWithoutTags,
  );
  if (!textToTranslate) return;

  core.info(`Translate origin body: ${textToTranslate}`);

  const translated = await translate(textToTranslate);
  if (!translated || translated === textToTranslate) {
    return core.warning('Translated text is null or identical. Ignoring.');
  }

  core.info(`Translated result: ${translated}`);

  let [translatedBody, translatedTitle] = translateText.parse(translated);

  /**
   * Mode 1 — Append translation to the original content
   */
  if (appendTranslation) {
    const finalTitle =
      !titleAlreadyTranslated &&
      translatedTitle &&
      translatedTitle !== originalTitleWithoutTags &&
      originalTitle &&
      formatTitleWithTags(originalTitle, translatedTitle);

    const finalBody =
      translatedBody &&
      translatedBody !== originalBodyForTranslation &&
      `${originalBodyWithQuotes}
${TRANSLATION_DIVIDER}
---
###### ${botNote}

${translatedBody}
`;

    await update(octokit, finalBody || undefined, finalTitle || undefined);
    return;
  }

  /**
   * Mode 2 — Post translation as a separate bot comment
   */
  const bodyChanged =
    translatedBody && translatedBody !== originalBodyForTranslation;

  const commentBody = `
> ${botNote}
----
${!modifyTitle && !titleAlreadyTranslated && translatedTitle && originalTitle ? `**Title:** ${formatTitleWithTags(originalTitle, translatedTitle)}\n` : ''}
${translatedBody ?? ''}
`.trim();

  // Update title if required
  if (
    modifyTitle &&
    !titleAlreadyTranslated &&
    translatedTitle &&
    translatedTitle !== originalTitleWithoutTags &&
    originalTitle
  ) {
    await update(
      octokit,
      undefined,
      formatTitleWithTags(originalTitle, translatedTitle),
    );
  }

  // Post comment if content changed
  if (bodyChanged) {
    await createIssueComment({
      pull_number: pull_request?.number,
      discussion_number: discussion?.node_id,
      issue_number: issue?.number,
      body: commentBody,
      octokit,
    });
  }

  core.setOutput('complete time', new Date().toTimeString());
}

async function run() {
  try {
    await main();
  } catch (err: any) {
    core.setFailed(err.message);
  }
}

run();
